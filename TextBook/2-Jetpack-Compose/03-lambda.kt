基本ルールとラムダ式
コンポーザブル関数は通常の関数（@Composable アノテーションが付いていない関数）と似ていますが、独自のルールがあります。

コードを書き始める前にコンポーザブル関数の基本ルールについて確認しておきましょう。

また Jetpack Compose を使った開発では ラムダ式 という書き方を多用します。独特な書き方なので慣れるまで難しいかもしれませんが、こちらも基本をおさえておきましょう。


もくじ
コンポーザブル関数の基本ルール
名前の付け方
① パスカルケースにする
② 名詞句にする
コンポーザブル関数の特徴
① パラメータを使用できる
② 値を返すことができない
③ 呼び出し制限
④ 関数の見分け方
ラムダ式
省略バージョン
ポイント① 関数を値にできる
ポイント② 関数をパラメータにできる
ポイント③ 後置ラムダ構文
詳細バージョン
① 関数を値にする
② パラメータと戻り値の書き方
③ 関数をパラメータにする
④ 後置ラムダ構文
まとめ

コンポーザブル関数の基本ルール
名前の付け方
① パスカルケースにする
通常の関数は小文字から始めるキャメルケースで書きましたが、コンポーザブル関数は大文字から始めるパスカルケースで書きます。

例） OmikujiComposeTheme, Greeting, GreetingPreview


② 名詞句にする
コンポーザブル関数の名前は名詞句にするというルールがあります。

通常の関数は、どんな処理をしているのかを表す名前にしました。

例） playSound（音を再生する）, getResult（結果を取得する）, generateRandomNumber（乱数を生成する）


コンポーザブル関数は UI を作成する関数なので、作成する画面・テキスト・画像など UI を表す名前にします。

慣れるまでは難しいですが「〜する」という意味にならないように注意してみましょう。

例） MainScreen（メインスクリーン）, MyButton（マイボタン）, DogImage（犬の画像）


コンポーザブル関数の特徴
次にコンポーザブル関数の特徴を紹介します。

こちらも通常の関数と比較しながら確認しておきましょう。


① パラメータを使用できる
通常の関数と同じように、コンポーザブル関数もパラメータを設定することができます。

例えば Greeting 関数はパラメータあり、GreetingPreview 関数はパラメータなしとなっています。

コンポーザブル関数のパラメータ
パラメータの省略
Greeting 関数は２つのパラメータ

name: String 型、初期値なし
modifier: Modifier 型、初期値は Modifier
を持っています。

@Composable
fun Greeting(name: String, modifier: Modifier = Modifier) {


初期値ありのパラメータは省略できるので、２通りの呼び出し方があります（参考：関数の基本ルール - ステップ5：パラメータに初期値を設定する）。

// 23行目あたり
Greeting(
    name = "Android",
    modifier = Modifier.padding(innerPadding)
)

// 45行目あたり
Greeting("World")


② 値を返すことができない
通常の関数は

処理をするだけの関数
処理をして値を返す関数
の２種類がありました。

コンポーザブル関数は UI を作成するための関数なので、処理をして値を返すことはできません。

例えば Greeting 関数では「何も返さない」という意味の Unit が省略されています。

Greeting関数

③ 呼び出し制限
コンポーザブル関数は、通常の関数内から呼び出すことができないという特徴があります。

つまり、コンポーザブル関数はコンポーザブル関数内からのみ呼び出すことができます。


以下のように通常の関数からコンポーザブル関数を呼び出そうとすると、赤い波線がついてエラーになります。

コンポーザブル関数の呼び出し
setContent メソッドは例外
20行目の setContent メソッドはコンポーザブル関数ではありませんが、アプリの入口（エントリポイント）になるメソッドなので、例外としてコンポーザブル関数を呼び出すことができます。


④ 関数の見分け方
コンポーザブル関数を定義する時は @Composable アノテーションがあるので分かりやすいですが、関数を使うときは「通常の関数なのか、コンポーザブル関数なのか」が分かりにくいかもしれません。

簡単な見分け方として

通常の関数は小文字から始まって青色
コンポーザブル関数は大文字から始まって緑色
になります（色はテーマによって変わります）。


見分け方①

また関数名にカーソルを合わせると小さいウィンドウが表示されます。

ここに元のコードが表示されるので @Composable アノテーションの有無をみることができます。

見分け方②
テキストやボタンを作成するコンポーザブル関数はパラメータがとても多くて、例えば Text 関数だけでも 17 個のパラメータがあります。

マウスオーバーで元のコードを確認しながらコードを書いていくので、この機能はぜひ覚えておきましょう。

Text 関数

ラムダ式
ここからは Jetpack Compose 開発で必ず知っておきたい ラムダ式 について紹介します。

慣れるまでは難しく感じる書き方なので、最低限知っておくべき 「省略バージョン」 と、詳しく知りたい方向けの 「詳細バージョン」 を用意しています。

すぐにアプリ開発に進みたいという方は、まずは省略バージョンのルールだけ覚えておきましょう。

サンプルコードを動かすときは、第２章で作成した KotlinProject か Kotlin Playground　をご利用ください。


詳細バージョン
詳細バージョンでは、ラムダ式に関する細かいルールもあわせて紹介していきます。

第２章で作成した KotlinProject か Kotlin Playground　を使って、実際にコードを書いてみましょう。


① 関数を値にする
ここまで、変数には文字列や数値を代入してきましたが、関数を代入することもできます。

// 文字列を代入
val message = "こんにちは"

// 関数を代入
val sayHello = { println("こんにちは") }


{ 処理 } のような書き方をラムダ式といって、fun キーワードをつけずに関数を定義できます。

通常の関数と同じように sayHello() で呼び出すことができます。

fun main() {
    val sayHello = { println("こんにちは") }
    sayHello()
}


この関数にもパラメータや戻り値を書くことができます。

sayHello のようにパラメータと戻り値がない場合は () -> Unit 型 が省略されている状態となっています。

val sayHello: () -> Unit = { println("こんにちは") }


() -> Unit という書き方は頻繁に出てくるので 「パラメータ・戻り値なしの関数」 と覚えておきましょう。



② パラメータと戻り値の書き方
パラメータと戻り値がある場合も考えてみましょう。

おみくじアプリでは generateRandomNumber 関数 を作りました。

fun generateRandomNumber(min: Int, max: Int) = (min..max).random()


この関数をラムダ式を使って書いてみましょう。

以下のコードから始めます。

fun main() {
    val generateRandomNumber: () -> Unit = {}
}


この関数は、最小値と最大値の２つのパラメータがあって、ランダムな数値を返します。

パラメータと戻り値は (パラメータの型) -> 戻り値の型 のように書いて、パラメータが複数あるときは , で区切ります。

generateRandomNumber 関数は、２つの Int 型パラメータをとって Int 型の値を返すので、(Int, Int) -> Int となります。

fun main() {
    val generateRandomNumber: (Int, Int) -> Int = {}
}


２つのパラメータに名前をつけます。

名前は何でも良いですが、ここでは min, max という名前にしました。最後に -> をつけることがポイントです。

fun main() {
    val generateRandomNumber: (Int, Int) -> Int = { min, max ->
    }
}


最後に戻り値を書きますが return キーワードは必要ありません。

ラムダ式では最後に実行されたコードが自動的に戻り値となります。

fun main() {
    val generateRandomNumber: (Int, Int) -> Int = { min, max ->
        (min..max).random()
    }
}


戻り値に注意
最後に実行されたコードが自動的に戻り値となるので、以下のコードでは 123 が結果として返されます。複数行のコードを書くときは注意しましょう。

val generateRandomNumber: (Int, Int) -> Int = { min, max ->
    (min..max).random()
    123 // ←これが戻り値になる
}



呼び出し方は通常の関数と同じで generateRandomNumber(0, 100) と書くだけです。

fun main() {
    val generateRandomNumber: (Int, Int) -> Int = { min, max ->
        (min..max).random()
    }
    println(generateRandomNumber(0, 100))
}


■ パラメータ名の省略
パラメータが複数あるときは min, max と名前を付けますが、パラメータが１つのときは特別な変数が用意されています。

min を削除、最小値を 0 にして、パラメータを max だけにします。

val generateRandomNumber: (Int) -> Int = { max -> 
    (0..max).random()
}


このようにパラメータが１つの場合は max -> を削除して、代わりに特別な変数 it で受け取った値を使用できます。

val generateRandomNumber: (Int) -> Int = {
    (0..it).random()
}


ただし it が何を意味しているのか分かりにくい場合は、it を使わずに変数名をつけましょう。

例えば、前回作成した Omikuji Compose プロジェクトの MainActivity.kt 22行目あたりのScaffold コンポーザブル関数 では、it を使わずに innerPadding -> と明示的に書いています。

innerPadding

③ 関数をパラメータにする
ここまでは関数が値になる例でしたが、「関数のパラメータ」として「関数」を書くこともできます。

以下の例では、２つのパラメータを持つ関数を用意しています。

名前がmessage、型がString
名前がaction、型が() -> Unit

fun printMessage(message: String, action: () -> Unit) {
    println(message)
    action()  // 渡された関数を実行
}


実際のコードも見てみましょう。

Omikuji Compose プロジェクトの MainActivity.kt 22行目あたりの Scaffold にカーソルを合わせて、Scaffold コンポーザブル関数のパラメータを表示します。

@Composable () -> Unit のように「コンポーザブル関数型のパラメータ」が用意されていることが分かります。

Scaffold 関数のパラメータ

高階関数
引数として関数を受け取ったり、戻り値として関数を返したりする関数を高階関数と言います。



④ 後置ラムダ構文
先ほど例として使ったprintMessage 関数 は以下のように呼び出すことができます。

fun main() {
    printMessage("こんにちは", { print("山田さん") })
}

fun printMessage(message: String, action: () -> Unit) {
    println(message)
    action()
}


Kotlin では、関数を呼び出すときに 「最後の引数が関数の場合は、この関数を()の外に出すことができる」 というルールがあります。

このルールをprintMessage 関数の呼び出しに適用すると、最後の引数 { print("山田さん") } は関数なので () の外に出すことができます。

fun main() {
    printMessage("こんにちは") { 
        print("山田さん") 
    }
}


後置ラムダ構文

これを後置ラムダ構文と言って、Jetpack Compose 開発では欠かすことのできない書き方です。

Omikuji Compose プロジェクトの MainActivity.kt に書いてあった Scaffold コンポーザブル関数 を見てみましょう。

Scaffold コンポーザブル関数には、modifierと content がパラメータとして用意されていました。

modifier, content パラメータ
通常の書き方で Scaffold コンポーザブル関数を呼び出すと、以下のようになります。

Scaffold(
    modifier = Modifier.fillMaxSize(),
    content = { 
        /*省略*/
    }
)


後置ラムダ構文のルールを使うと、最後の引数 content は関数なので () の外に出すことができます。

Scaffold(modifier = Modifier.fillMaxSize()) { 
    /* 省略 */
}


後置ラムダ構文

20 行目のsetContent メソッドと 21 行目のOmikujiComposeTheme コンポーザブル関数も、引数が関数１つだけなので () の外に出して {} だけになっています。

MainActivity.kt
後置ラムダ構文を使うメリット
後置ラムダ構文を使う一番のメリットは、コードが読みやすくなること（可読性アップ） です。

Jetpack Compose のコードは、基本的に コンポーザブル関数名（設定）{ 中身 } という構造になります。

例えば、次回紹介するボタンを作成するコードは、以下のように書きます。

Button (
  onClick = { /* ボタンが押された時の処理 */ }
) {
    Text("ボタンのテキスト")
}

ボタンが押された時の処理 （設定） とボタンのテキスト （中身） を分けて書くことができるので、直感的に分かりやすいコードになっています。

後置ラムダ構文を使ったコードは今後たくさん出てくるので、コードを書きながら慣れていきましょう。


省略バージョン詳細バージョン


まとめ
コンポーザブル関数
UI を作成するための関数
関数名はパスカルケースで名詞句
値を返すことができない
コンポーザブル関数内からのみ呼び出すことができる
ラムダ式
値とパラメータに関数を書ける
() -> Unit は引数と戻り値がない関数
最後の引数が関数の場合は、その関数を () の外に出すことができる（後置ラムダ構文）
